# AI with kaboom

In this tutorial, we will illustrate how we can use Artificial intelligence(AI) to create a cat and mouse game in which a player has to escape an enemy chasing and shooting at them.

We will provide the computer with a few sets of instructions and allow it to handle the movement of the enemy sprite. All we have to control are the player's movement when playing the game.

![ai](ai.png)


You can find the code for this tutorial on [Replit](https://replit.com/@ritza/ai-1) or try the embedded repl below.

## Getting started

Use the following code to initialize a kaboom context:

```javascript
import kaboom from "kaboom"

kaboom()
```

We'll need two sprites for the game we're building, add the following imports below the previous code:

```javascript
loadSprite("bean", "/sprites/bean.png")
loadSprite("ghosty", "/sprites/ghosty.png")
```

Let's declare a few constants for the moving speed of each of our sprites in the game. Add the following code below the sprite imports:

```javascript

const SPEED = 320
const ENEMY_SPEED = 160
const BULLET_SPEED = 800
```

## Adding game objects

We need to create game objects to hold our player and enemy sprites. Let's start with our player, add the following code to your program:


```javascript

const player = add([
    sprite("bean"),
    pos(80, 80),
    area(),
    origin("center"),
])
```
In the code above, we assign the "bean" sprite to the player object we've created. Using the `pos()` function we give it a starting position at the top-left corner of the game screen when the game begins. With the `area()` function, we give the player a body that we will use to register collisions with the enemy sprites or with the bullets.

Add the following code for the enemy sprite:

```javascript
const enemy = add([
    sprite("ghosty"),
    pos(width() - 80, height() - 80),
    origin("center"),
    state("move", [ "idle", "attack", "move", ]),
])
```

  The second sprite "ghosty" is assigned to the enemy object. Using the `pos()` function, we position the enemy sprite 80 units from the width and height of the game screen. The `state()` function is used to give the enemy object 3 different states and we will be able to program the enemy's behavior in each state.
  
## Adding state behavior
In this section, we will determine what happens in all 3 states of the enemy sprite. Add the following code below the enemy object we created in the previous section:


```javascript
enemy.onStateEnter("idle", async () => {
    await wait(0.5)
    enemy.enterState("attack")
})

```
In the code above, we use the `onStateEnter()` function to switch between the different states. The initial behavior of our enemy object will be "idle" and we use the the `wait()` to wait 0.5 seconds before switching to the "attack" state.

Add the following code below the previous `onStateEnter()` to implement the attack state:

```javascript
enemy.onStateEnter("attack", async () => {
    if (player.exists()) {

        const dir = player.pos.sub(enemy.pos).unit()

        add([
            pos(enemy.pos),
            move(dir, BULLET_SPEED),
            rect(12, 12),
            area(),
            cleanup(),
            origin("center"),
            color(BLUE),
            "bullet",
        ])

    }

    await wait(1)
    enemy.enterState("move")

})
```
In the line, `
const dir = player.pos.sub(enemy.pos).unit()` we get the direction of the player's position relevant to the enemy's position and shoot a bullet that moves towards the player. 

In the `add()` function, We create a new bullet by creating a small, blue rectangle to represent the bullet and we pass it in the direction of the player to move toward. Once the bullet reaches the player's position, the `area()` component will be used to determine if there was a collision if there was no collision, the `cleanup()` function will remove the bullet from the game screen.

Once the enemy shoots a bullet, they will wait 1 second after it is fired then switch to the "move" state.

Add the following code below the previous `onStateEnter()` function to implement the "move" state:

```javascript
enemy.onStateEnter("move", async () => {
    await wait(2)
    enemy.enterState("idle")
})
```
Similarly to the "idle" state, the enemy will wait 2 seconds in the "move" state before switching to idle.

However, the enemy needs to keep chasing the player as long as they aren't hit by a bullet- in which case they disappear- while the player still exists the enemy will keep chasing. 

Add the following code to implement this behavior:

```javascript

enemy.onStateUpdate("move", () => {
    if (!player.exists()) return
    const dir = player.pos.sub(enemy.pos).unit()
    enemy.move(dir.scale(ENEMY_SPEED))
})
```
The `onStateUpdate()` function above will update the state of the enemy in each frame but only if the current state of the enemy object is "move" because it means the player still exists.

The line `if (!player.exists())` will make us return from the function if the player no longer exists, or else the enemy will keep moving in the direction of the player as seen in this line `enemy.move(dir.scale(ENEMY_SPEED))`

The following code will call the `enterState()` function to initiate the state changes after the game begins, add this below the `onStateUpdate()` function:

```javascript
enemy.enterState("move")
```

## Detecting collisions

If the player collides with the bullet, both the player and the bullet have to disappear. Add the following code below the `enterState()` function to implement this behavior:

```javascript
player.onCollide("bullet", (bullet) => {
    destroy(bullet)
    destroy(player)
    addKaboom(bullet.pos)
})
```

The `destroy()` function in the code above will remove both the bullet and the player from the game screen.


## Adding player movement

To move our player, we will use the keyboard arrow keys to register their movement.Add the following code below the `onCollide()` function:

```javascript
onKeyDown("left", () => {
    player.move(-SPEED, 0)
})

onKeyDown("right", () => {
    player.move(SPEED, 0)
})

onKeyDown("up", () => {
    player.move(0, -SPEED)
})

onKeyDown("down", () => {
    player.move(0, SPEED)
})
```
In the code above, we use the `SPEED` variable to set the direction and speed of the player's movement in the positive direction(up/right) ad the negative direction(down/left).


### Things to try

Here are some ideas to make the game more entertaining:

- Try to add some background music for the duration of the game
- Add a score or timer and a new enemy sprite if the player reaches a certain score/time.


You can try out the code in the embedded repl below:

<iframe height="400px" width="100%" src="https://replit.com/@ritza/ai-1?embed=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
